#!/usr/bin/env python
"""
Usage: mulder [<backup>]
"""
import ConfigParser
import datetime
import os
import subprocess
import sys
import tarfile
import tempfile
import textwrap

from boto.exception import S3ResponseError
from boto.s3.connection import S3Connection
from boto.s3.key import Key

try:
    import progressbar
    HAS_PROGRESSBAR = True
except ImportError:
    HAS_PROGRESSBAR = False


FILE = '~/.mulder'
TMPDIR = tempfile.gettempdir()
MESSAGE_WIDTH = 72


def error(msg, exitcode=1):
    """
    Print ``msg`` to stderr and exit with ``exitcode``.
    """
    msg = os.path.basename(sys.argv[0]) + ': ' + msg
    msg = '\n'.join(textwrap.wrap(msg, MESSAGE_WIDTH)) + '\n'
    sys.stderr.write(msg)
    sys.exit(exitcode)

def expand(fn):
    """
    Fully expand a path.
    """
    fn = os.path.expandvars(fn)
    fn = os.path.expanduser(fn)
    return os.path.abspath(fn)


class Mulder(object):

    OPTIONS = ['bucket', 'exclude', 'files', 'gpg', 'name', 'access_key', 'secret_key']

    def __init__(self):
        self.setup_config()

    def backup(self, backup):
        """
        Run a backup.
        """
        # make sure the requested backup exists
        try:
            options = self.options[backup]
        except KeyError:
            error("Invalid backup '%s'" % backup)

        # check for backup-specific AWS keys
        for key in ['access_key', 'secret_key']:
            try:
                options[key] = self.options[backup][key]
            except KeyError:
                options[key] = self.options['auth'][key]

        backup = Backup(**options)
        backup.run()

    def eval(self, cmd):
        """
        Call ``cmd``, returning it's stdout output.
        """
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip()

    def setup_config(self):
        """
        Parse config file.
        """
        self.config = ConfigParser.ConfigParser()
        self.backups = []
        self.options = {}

        try:
            self.config.readfp(open(expand(FILE)))
        except IOError:
            error("Couldn't read your config file.")

        for section in self.config.sections():
            if section != 'auth':
                self.backups.append(section)

            self.options[section] = {}
            for option in self.OPTIONS:
                # regular option
                if self.config.has_option(section, option):
                    self.options[section][option] = self.config.get(section, option)

                # _eval option
                if self.config.has_option(section, option + '_eval'):
                    cmd = self.config.get(section, option + '_eval')
                    self.options[section][option] = self.eval(cmd)



class Backup(object):

    REQUIRED_OPTIONS = ['bucket', 'name', 'files']

    def __init__(self, bucket, name, files, **kwargs):
        self.bucket = bucket
        self.name = name
        self.files = files

        # set the options
        for k, v in kwargs.items():
            setattr(self, k, v)

        # validate options, file and S3 connections
        # best to do this here so we don't create any unneccesary files
        # or network connections
        self.validate_options()
        self.validate_exclude()
        self.validate_files()
        self.setup_connection()

    def run(self):
        """
        Create an archive and upload it, encrypting if necessary.
        """
        try:
            self.create_archive()
            self.encrypt_archive()
            self.upload_archive()
        except S3ResponseError, e:
            error("Error in backup '%s': %s" % (self.backup, e.error_message))
        except Exception as e:
            error(e)
        finally:
            self.cleanup()

    def cleanup(self):
        """
        Removes any archives created by the backup.
        """
        for fn in self.archives:
            os.unlink(fn)

    def create_archive(self):
        """
        Create the archive from the given list of files.
        """
        filename = datetime.datetime.now().strftime(self.name) + '.tar.gz'
        filename = os.path.join(TMPDIR, filename)

        tarball = tarfile.open(filename, 'w|gz')
        for fn in self.files:
            tarball.add(fn, exclude=self.excluded)
        tarball.close()

        self.archive = filename
        self.archives = [filename]

    def encrypt_archive(self, force=False):
        """
        Encrypt the archive if necessary (or if forced).
        """
        if getattr(self, 'gpg', force):
            cmds = ['gpg', '--encrypt', '--default-recipient-self', self.archive]
            proc = subprocess.Popen(cmds)
            proc.communicate()
            self.archive = self.archive + '.gpg'
            self.archives.append(self.archive)

    def excluded(self, tarinfo):
        """
        Checks if a file should be excluded from the archive.
        """
        return tarinfo in self.exclude

    def upload_archive(self):
        """
        Upload the archive to S3.
        """
        size = os.stat(self.archive).st_size
        basename = os.path.basename(self.archive)
        bucket = self.conn.get_bucket(self.bucket)
        key = Key(bucket)
        key.name = basename
        self.start_progressbar(basename, size)
        key.set_contents_from_filename(self.archive, cb=self.update_progressbar, num_cb=100)

    def setup_connection(self):
        """
        Set up a connection to S3.
        """
        self.conn = S3Connection(self.access_key, self.secret_key)

    def start_progressbar(self, filename, size):
        if not HAS_PROGRESSBAR:
            return
        widgets = [
            filename, ' ', progressbar.Bar(), ' ',
            progressbar.FileTransferSpeed(), ' | ', progressbar.Percentage(),
            ' ',  progressbar.ETA()
        ]
        self.progressbar = progressbar.ProgressBar(widgets=widgets, maxval=size)
        self.progressbar.start()

    def finish_progressbar(self):
        """
        Finish progress bar.
        """
        if HAS_PROGRESSBAR:
            self.progressbar.finish()

    def update_progressbar(self, current, total):
        """
        Update progress bar.
        """
        if HAS_PROGRESSBAR:
            self.progressbar.update(current)

    def validate_exclude(self):
        """
        Expand all the filenames in the exclude option. We do not need
        to validate the each file exists as it would be excluded
        anyway.
        """
        exclude = []
        for fn in self.exclude.split(','):
            exclude.append(expand(fn.strip()))
        self.exclude = exclude

    def validate_files(self):
        """
        Make sure the files option is not empty and that each file
        exists.
        """
        if not self.files:
            error("No files specified for backup '%s'" % self.backup)

        files = []
        for fn in self.files.split(','):
            fn = expand(fn.strip())
            if not any([os.path.isfile(fn), os.path.isdir(fn)]):
                error("Invalid file/directory '%s' for backup '%s'" % (fn, self.backup))
            files.append(fn)
        self.files = files

    def validate_options(self):
        """
        Make sure each required option is present.
        """
        for option in self.REQUIRED_OPTIONS:
            if not getattr(self, option, None):
                error("Backup '%s' is missing option '%s'" % (self.backup, option))


def main():
    # help message
    if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help'):
        sys.stderr.write(__doc__.lstrip())
        sys.exit(2)

    # the heavy lifter
    mulder = Mulder()

    # list all backups
    if len(sys.argv) == 1:
        sys.stdout.write('\n'.join(mulder.backups) + '\n')
        sys.exit(0)

    # do it
    mulder.backup(sys.argv[1])

if __name__ == '__main__':
    main()
