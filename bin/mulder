#!/usr/bin/env python
"""
Usage: mulder [<backup>]
"""
import datetime
import mimetypes
import os
import subprocess
import sys
import tarfile
import tempfile

try:
    import configparser
except ImportError:
    import ConfigParser as configparser


FILE = '~/.mulder'
TMPDIR = tempfile.gettempdir()


def error(msg, exitcode=1):
    """
    Print ``msg`` to stderr and exit with ``exitcode``.
    """
    msg = os.path.basename(sys.argv[0]) + ': ' + msg
    sys.stderr.write(msg + '\n')
    sys.exit(exitcode)


def expand(fn):
    """
    Fully expand a path.
    """
    fn = os.path.expandvars(fn)
    fn = os.path.expanduser(fn)
    return os.path.abspath(fn)


class FileIterable(object):
    def __init__(self, filename, chunksize, callback):
        self.filename = filename
        self.chunksize = chunksize
        self.callback = callback
        self.totalsize = os.path.getsize(filename)
        self.readsofar = 0

    def __iter__(self):
        with open(self.filename, 'rb') as file:
            while True:
                data = file.read(self.chunksize)
                if not data:
                    sys.stderr.write("\n")
                    break
                self.readsofar += len(data)
                self.callback(self.readsofar, self.totalsize)
                yield data

    def __len__(self):
        return self.totalsize

    def read(self, size=-1):
        return next(self, b'')


class FileIterator(object):
    def __init__(self, fn, chunksize, callback=None):
        iterable = FileIterable(fn, chunksize, callback)
        self.iterator = iter(iterable)
        self.length = len(iterable)

    def read(self, size=-1):
        return next(self.iterator, b'')

    def __len__(self):
        return self.length


class Uploader(object):

    CONTENT_TYPE = 'application/octet-stream'

    def __init__(self, options):
        self.options = options

    def content_type(self, fn):
        """
        Get the content type for a given filename.
        """
        ext = os.path.splitext(fn)[-1]
        return mimetypes.types_map.get(ext, self.CONTENT_TYPE)

    def progress(self, cur, total):
        """
        Display a very simple percentage-based progress bar.
        """
        sys.stderr.write("\r%s%%" % str(cur * 100 / total))
        sys.stderr.flush()


class RsyncUploader(Uploader):
    """
    Transfer a file via rsync.
    """

    scheme = 'rsync'

    def upload(self, fn):
        cmds = ['rsync', '-a', '-z', '--progress', fn, self.options['destination']]
        proc = subprocess.Popen(cmds)
        proc.communicate()


class S3Uploader(Uploader):
    """
    Upload a file to S3.
    """

    scheme = 's3'
    buffer_size = 1024 * 1024

    def upload(self, fn):
        import botocore.session

        session = botocore.session.get_session()
        session.set_credentials(self.options['access_key'], self.options['secret_key'])
        service = session.get_service('s3')
        endpoint = service.get_endpoint()

        ct = self.content_type(fn)
        key = os.path.basename(fn)
        bucket = self.options['destination']
        body = FileIterator(fn, self.buffer_size, self.progress)
        op = service.get_operation('PutObject')
        op.call(endpoint, bucket=bucket, key=key, body=body, content_type=ct)


class Backup(object):

    REQUIRED_OPTIONS = ['destination', 'name', 'files']

    def __init__(self, options):
        self.options = {}
        self.backup_options = {}

        self.setup_config(options)
        self.validate_options()
        self.validate_destination()
        self.validate_exclude()
        self.validate_files()

    def cleanup(self):
        """
        Removes any archives created by the backup.
        """
        for fn in self.archives:
            os.unlink(fn)

    def create_archive(self):
        """
        Create the archive from the given list of files.
        """
        filename = datetime.datetime.now().strftime(self.options['name']) + '.tar.gz'
        filename = os.path.join(TMPDIR, filename)

        tarball = tarfile.open(filename, 'w|gz')
        for fn in self.files:
            try:
                # use filter for Python 2.7+
                tarball.add(fn, filter=self.filter)
            except TypeError:
                tarball.add(fn, exclude=self.excluded)
        tarball.close()

        self.archive = filename
        self.archives = [filename]

    def encrypt_archive(self):
        """
        Encrypt the archive if necessary.
        """
        if not self.options.get('gpg', False):
            cmds = ['gpg', '--encrypt', '--default-recipient-self', self.archive]
            proc = subprocess.Popen(cmds)
            proc.communicate()
            self.archive = self.archive + '.gpg'
            self.archives.append(self.archive)

    def eval(self, cmd):
        """
        Call ``cmd``, returning it's stdout output.
        """
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip().decode('utf-8')

    def excluded(self, tarinfo):
        """
        Checks if a file should be excluded from the archive.
        """
        return tarinfo in self.exclude

    def filter(self, tarinfo):
        """
        Checks if a file should be excluded from the archive.
        """
        if '/' + tarinfo.name in self.exclude:
            return None
        return tarinfo

    def run(self):
        """
        Create an archive and upload it, encrypting if necessary.
        """
        try:
            self.create_archive()
            self.encrypt_archive()
            self.upload_archive()
        finally:
            self.cleanup()

    def setup_config(self, options):
        """
        Set up configuration for this backup.
        """
        for key, value in options.items():
            if key.endswith('_eval'):
                value = self.eval(value)
                key = key.replace('_eval', '')

            if key in self.REQUIRED_OPTIONS:
                self.options[key] = value
            else:
                self.backup_options[key] = value


    def upload_archive(self):
        """
        Upload the archive.
        """
        for dest in self.destinations:
            dest.upload(self.archive)

    def validate_destination(self):
        """
        Validate destination.
        """
        destinations = []

        for d in self.options['destination'].split(','):
            scheme, destination = d.strip().split('://', 1)
            uploader = None

            for u in Uploader.__subclasses__():
                if scheme == u.scheme:
                    self.backup_options['destination'] = destination
                    uploader = u(self.backup_options)
                    break

            if not uploader:
                error('Unknown scheme "%s".' % scheme)

            destinations.append(uploader)

        self.destinations = destinations


    def validate_exclude(self):
        """
        Expand all the filenames in the exclude option. We do not need
        to validate the each file exists as it would be excluded
        anyway.
        """
        exclude = []
        for fn in self.options.get('exclude', '').split(','):
            exclude.append(expand(fn.strip()))
        self.exclude = exclude

    def validate_files(self):
        """
        Make sure the files option is not empty and that each file
        exists.
        """
        if not self.options['files']:
            error("No files specified.")

        files = []
        for fn in self.options['files'].split(','):
            fn = expand(fn.strip())
            if not any([os.path.isfile(fn), os.path.isdir(fn)]):
                error("Invalid file/directory '%s'." % fn)
            files.append(fn)
        self.files = files

    def validate_options(self):
        """
        Make sure each required option is present.
        """
        for option in self.REQUIRED_OPTIONS:
            if not self.options.get(option, None):
                error("Missing required option '%s'." % option)


def main():
    config = configparser.ConfigParser()

    try:
        config.readfp(open(expand(FILE)))
    except IOError:
        error("Couldn't read your config file.")

    # list all backups
    if len(sys.argv) == 1:
        sys.stdout.write('\n'.join(sorted(config.sections())) + '\n')
        sys.exit(0)

    # does the backup exist?
    try:
        options = dict(config.items(sys.argv[1]))
    except configparser.NoSectionError:
        error("Invalid backup '%s'" % sys.argv[1])

    # backup is good. let's do it
    backup = Backup(options)
    backup.run()


if __name__ == '__main__':
    main()
