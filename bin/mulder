#!/usr/bin/env python
"""
Usage: mulder [<backup>]
"""
import ConfigParser
import datetime
import os
import subprocess
import sys
import tarfile
import tempfile
import textwrap

from boto.exception import S3CreateError, S3ResponseError
from boto.s3.connection import Location, S3Connection
from boto.s3.key import Key

try:
    import progressbar
    HAS_PROGRESSBAR = True
except ImportError:
    HAS_PROGRESSBAR = False


FILE = os.path.expanduser('~/.mulder')
TMPDIR = tempfile.gettempdir()


class Base(object):
    message_width = 79

    def error(self, msg, exitcode=1):
        """
        Print ``msg`` to stderr and exit with ``exitcode``.
        """
        msg = os.path.basename(sys.argv[0]) + ': ' + msg
        msg = '\n'.join(textwrap.wrap(msg, self.message_width)) + '\n'
        sys.stderr.write(msg)
        sys.exit(exitcode)

    def expand(self, fn):
        """
        Fully expand a path.
        """
        fn = os.path.expandvars(fn)
        fn = os.path.expanduser(fn)
        return os.path.abspath(fn)


class Mulder(Base):

    def __init__(self):
        self.setup_config()
        self.setup_auth()

    def backup(self, backup):
        """
        Run a backup.
        """
        if not self.config.has_section(backup):
            self.error("Invalid backup '%s'" % backup)

        # build a dict to pass to Backup()
        opts = {}
        for tpl in self.config.items(backup):
            opts[tpl[0]] = tpl[1]
        opts['backup'] = backup
        opts['access_key'] = self.access_key
        opts['secret_key'] = self.secret_key

        backup = Backup(**opts)
        backup.run()

    def eval_option(self, cmd):
        """
        Call ``cmd``, returning it's stdout output.
        """
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)
        return proc.communicate()[0].strip()

    def setup_auth(self):
        """
        Set up the S3 authentication.
        """
        for option in ['access_key', 'secret_key']:
            # try to get the regular options
            if self.config.has_option('auth', option):
                value = self.config.get('auth', option)
                setattr(self, option, value)

            # try to get the `_eval` option
            if self.config.has_option('auth', option + '_eval'):
                value = self.eval_option(self.config.get('auth', option + '_eval'))
                setattr(self, option, value)

            # couldn't find any option
            if not getattr(self, option, ''):
                self.error("Missing option '%s' in your config file." % option)

    def setup_config(self):
        """
        Parse config file.
        """
        self.config = ConfigParser.ConfigParser()
        self.backups = []

        try:
            self.config.readfp(open(self.expand(FILE)))
        except IOError:
            self.error("Couldn't read your config file.")

        for section in self.config.sections():
            if section != 'auth':
                self.backups.append(section)


class Backup(Base):

    REQUIRED_OPTIONS = ['bucket', 'name', 'files']

    def __init__(self, **kwargs):
        # set the options
        # TODO: this is kinda ugly, find a cleaner way to handle it
        for k, v in kwargs.items():
            setattr(self, k, v)

        # validate options, file and S3 connections
        # best to do this here so we don't create any unneccesary files
        # or network connections
        self.validate_options()
        self.validate_files()
        self.setup_connection()

    def run(self):
        """
        Create an archive and upload it, encrypting if necessary.
        """
        try:
            self.create_archive()
            self.encrypt_archive()
            self.upload_archive()
        except S3ResponseError, e:
            self.error(e.error_message)
        except Exception as e:
            self.error(e)
        finally:
            self.cleanup()

    def cleanup(self):
        """
        Removes any archives created by the backup.
        """
        for fn in self.archives:
            os.unlink(fn)

    def create_archive(self):
        """
        Create the archive from the given list of files.
        """
        filename = datetime.datetime.now().strftime(self.name) + '.tar.gz'
        filename = os.path.join(TMPDIR, filename)

        tarball = tarfile.open(filename, 'w|gz')
        for fn in self.files:
            tarball.add(fn, filter=self.validate_exclude)
        tarball.close()

        self.archive = filename
        self.archives = [filename]

    def encrypt_archive(self, force=False):
        """
        Encrypt the archive if necessary (or if forced).
        """
        if getattr(self, 'gpg', force):
            cmds = ['gpg', '--encrypt', '--default-recipient-self', self.archive]
            proc = subprocess.Popen(cmds)
            proc.communicate()
            self.archive = self.archive + '.gpg'
            self.archives.append(self.archive)

    def upload_archive(self):
        """
        Upload the archive to S3.
        """
        size = os.stat(self.archive).st_size
        basename = os.path.basename(self.archive)
        bucket = self.conn.get_bucket(self.bucket)
        key = Key(bucket)
        key.name = basename
        self.start_progressbar(basename, size)
        key.set_contents_from_filename(self.archive, cb=self.update_progressbar, num_cb=100)

    def setup_connection(self):
        """
        Set up a connection to S3.
        """
        self.conn = S3Connection(self.access_key, self.secret_key)

    def start_progressbar(self, filename, size):
        if not HAS_PROGRESSBAR:
            return
        widgets = [
            filename, ' ', progressbar.Bar(), ' ',
            progressbar.FileTransferSpeed(), ' | ', progressbar.Percentage(),
            ' ',  progressbar.ETA()
        ]
        self.progressbar = progressbar.ProgressBar(widgets=widgets, maxval=size)
        self.progressbar.start()

    def finish_progressbar(self):
        """
        Finish progress bar.
        """
        if HAS_PROGRESSBAR:
            self.progressbar.finish()

    def update_progressbar(self, current, total):
        """
        Update progress bar.
        """
        if HAS_PROGRESSBAR:
            self.progressbar.update(current)

    def validate_files(self):
        """
        Make sure the files option is not empty and that each file
        exists.
        """
        if not self.files:
            self.error("No files specified for backup '%s'" % self.backup)

        files = []
        for fn in self.files.split(','):
            fn = self.expand(fn.strip())
            if not any([os.path.isfile(fn), os.path.isdir(fn)]):
                self.error("Invalid file/directory '%s' for backup '%s'" % (fn, self.backup))
            files.append(fn)
        self.files = files

    def validate_exclude(self, tarinfo):
        """
        Checks if a file should be excluded from the archive.
        """
        if tarinfo in getattr(self, 'exclude', []):
            return None
        return tarinfo

    def validate_options(self):
        for option in self.REQUIRED_OPTIONS:
            if not getattr(self, option, None):
                self.error("Backup '%s' is missing option '%s'" % (self.backup, option))


def main():
    # help message
    if len(sys.argv) > 1 and sys.argv[1] in ('-h', '--help'):
        sys.stderr.write(__doc__.lstrip())
        sys.exit(2)

    # the heavy lifter
    mulder = Mulder()

    # list all backups
    if len(sys.argv) == 1:
        sys.stdout.write('\n'.join(mulder.backups))
        sys.exit(0)

    # do it
    mulder.backup(sys.argv[1])

if __name__ == '__main__':
    main()
